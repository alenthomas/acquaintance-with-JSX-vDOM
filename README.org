#+TITLE: Building your own React
#+AUTHOR: Alen Thomas

** Step One: The virtual DOM representation
   - React supports stateless components in the form of pure functions
#+BEGIN_SRC js
const WelcomeComponent = ({ name }) => <div>Welcome {name}!</div>;

const RootComponent = ({ user }) => {
  if (user) {
    return <WelcomeComponent name = { user.name } />;
  } else {
    return <div>Please, Login</div>;
  }
}
#+END_SRC

   - This also allows cool compositions
#+BEGIN_SRC js
const welcome = name => 'Welcome ${ name } !';

const root = user => {
  if (user) {
    return welcome(user.name)
  } else {
    return 'Please Login';
  }
}
#+END_SRC
   - React allows node type to be either a =string= or a =component= i.e. /function/
   - Every rendering cycles starts by creating a vDOM representation
   - The vDOM representation mirrors the actual DOM
** Step two: Optimizing the Virtual DOM
   - stateless components can be memoized and returned
#+BEGIN_SRC js
const memoize = component => {
let lastProps = null;
let lastResult = null;

return props => {
  if (!shallowEqual(props, lastProps)) {
    lastResult = component(props);
    lastProps = props;

    lastResult.memoized = true;
  } else {
    lastResult.memoized = false;
  }
  return lastResult;
  };
};
#+END_SRC
   - now we adjust the =createVDOM= function to stop recursing when it reaches a cached subtree
** Step three: Identifying DOM Changes
   - done using tree diffing
#+BEGIN_SRC js
const RootComponent = ({ showDiv }) => {
  if (showDiv) {
    return h('div', {}, ['Hello World']);
  } else {
    return h('span', {}, ['Hello World']);
  }
}

const leftVDOM = createVDOM(h(RootComponent, { showDiv: true }));
const rightVDOM = createVDOM(h(RootComponent, { showDiv: false }));

const diff = (left, right, patches) => {
// TODO
}

const patches = [];
diff(leftVDOM, rightVDOM, patches);
#+END_SRC
   - our fundamental assumption is that different components will always generate different DOM subtrees
   - we short-circuit the tree comparison if we encounter a subtree
     whose root component has a different type from the corresponding node in the other tree.
   - in this case we recreate the entire subtree from scratch
#+BEGIN_SRC js
const diff = (left, right, patches, parent=null) => {
  if (!left) {
    patches.push({
      parent,
      type: PatchTypes.PATCH_CREATE_NODE,
      node: right
    });
  } else if (!right) {
    patches.push({
      type: PatchTypes.PATCH_REMOVE_NODE,
      node: left
    });
  } else if (left.type !== right.type) {
    patches.push({
      type: PatchTypes.PATCH_REPLACE_NODE,
      replacingNode: left,
      node: right
    });
  } else if (right.memoized) {
    return;
  } else {
    const children = left.children.length >= right.children.length ?
      left.children : right.children;

    children.forEach((child, index) => diff(
      left.children[index],
      right.children[index],
      patches,
      left
    ));
  }
};
#+END_SRC
** Step four: Applying changes to the DOM
   - we have a =applyPatch=, it compares the vDOM and DOM diffs and applies patches
#+BEGIN_SRC js
const ID_KEY = 'data-react-id';

const correlateVDOMNODE = (vdomNode, domRoot) => {
  if (vdomNode === null) {
    return domRoot;
  } else {
    return document.querySelector(`[${ID_KEY}="${vdomNode.id}"]`);
  }
}

const createNodeRecursive = (vdomNode, domNode) => {
  const domElement = document.createElement(vdomNode.type);
  domElement.setAttribute(ID_KEY, vdomNode.id);
  domNode.appendChild(domElement);
  vdomNode.children.forEach((child) =>
    createNodeRecursive(child, domElement));
};

const applyPatch = (patch, domRoot) => {
  switch(patch.type) {
    case PatchTypes.PATCH_CREATE_NODE: {
      const domNode = correlateVDOMNode(patch.parent, domRoot);
      createNodeRecursive(patch.node, domNode);
    }
    break;

    case PatchTypes.PATCH_REMOVE_NODE: {
      const domNode = correlateVDOMNode(patch.node, domRoot);
      domNode.parentNode.removeChild(domNode);
    }
    break;

    case PatchTypes.PATCH_REPLACE_NODE: {
      const domNode = correlateVDOMNode(patch.replacingNode, domRoot);
      const parentDomNode = domNode.parentNode;
      parentDomNode.removeChild(domNode);
      createNodeRecursive(patch.node, parentDomNode);
    }
    break;

    default:
      throw new Error(`Missing implementation for patch ${patch.type}`);
  }
};
#+END_SRC
** Step five: Render Function
   - function remembers the previous DOM state, finds any changes with the
     newly created vDOM
   - these changes are then applied to the actual DOM
#+BEGIN_SRC js
export const createRender = domElement => {
  let lastVDOM = null;
  let patches = null;

  return element => {
    const vdom = createVDOM(element);

    patches = [];
    diff(lastVDOM, vdom, patches);

    patches.forEach(patch => applyPatch(patch, domElement));

    lastVDOM = vdom;
  };
};
#+END_SRC
